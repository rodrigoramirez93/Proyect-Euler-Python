#Proyect Euler

# Problem 1
#If we list all the natural numbers below 10 that are multiples of 3 or 5, 
# we get 3, 5, 6 and 9. The sum of these multiples is 23.
#Find the sum of all the multiples of 3 or 5 below 1000.
 
res = 0

for numbers in range(1000):
    if (numbers % 3 == 0 or numbers % 5 == 0):
        res = res + numbers

print(res)

#Problem 2

#Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
# By starting with 1 and 2, the first 10 terms will be:
#1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#By considering the terms in the Fibonacci sequence whose values do not exceed four million, 
# find the sum of the even-valued terms.


fibo = [1,2]
i = 0
res = []

def fibonacci_recursive(fibo,i):
        if (fibo[i+1] > 4000000):
                fibo.pop(i+1)
                return
        else:
                fibo.append(fibo[i]+fibo[i+1])
                i += 1
                fibonacci_recursive(fibo,i)

fibonacci_recursive(fibo,i)

for numbers in fibo:
        if numbers % 2 == 0:
                res.append(numbers)

print(sum(res))

#Problem 3
# The prime factors of 13195 are 5, 7, 13 and 29.
# What is the largest prime factor of the number 600851475143 

import sys
sys.setrecursionlimit(10000)

number = 100
listFactors = []
i = 2

#Gets all factors
def factoring_recursive(number,listFactors, i):
        if number == 1:
                return
        if number % i == 0:
                number = number/i
                listFactors.append(i)
                factoring_recursive(number, listFactors, i)
        else:
                i += 1
                factoring_recursive(number, listFactors, i)
        
factoring_recursive(number,listFactors, i)

print('List of factors of ' + str(number) + ': ' + str(listFactors) + '\n')

#Check if number is prime
def isPrime(number):
        divideBy = []
        for n in range(number - 1):
                if number % (n+2) == 0:
                        divideBy.append(n+2)

        if (divideBy == [] or divideBy == [number]):
                print(str(number) + ' is prime')
                return True
        else:
                print('It\'s not prime, rest = 0 on :  ' +  str(divideBy))
                return False

primes = []

def getMaxPrime(listFactors):
        DistinctListFactors = list(dict.fromkeys(listFactors))
        for numbers in DistinctListFactors:
                if(isPrime(numbers)):
                        primes.append(numbers)
        return max(primes)

res = getMaxPrime(listFactors)
print('\n' + 'Max prime is: ' + str(res))


#Problem 4
#A palindromic number reads the same both ways. 
# The largest palindrome made from the product of two 2-digit numbers
# is 9009 = 91 Ã— 99.
#Find the largest palindrome made from the product of two 3-digit numbers.

palindrome = []


def isPalindrome(number):
        numberStr = str(number)
        numberLength = len(numberStr)
        if (numberLength % 2 == 0): #check if even 
                firstPart = numberStr[:int(numberLength/2)]
                secondPart = numberStr[int(numberLength/2):]
                if(firstPart == secondPart[::-1]):
                        return True
                else:
                        return False
        else: #odd
                firstPart = numberStr[:int(numberLength/2)]
                secondPart = numberStr[int(numberLength/2)+1:]
                if(firstPart == secondPart[::-1]):
                        return True
                else:
                        return False



for number in range(1,999):
        for numbertwo in range(1,999):
                n = number * numbertwo
                if (isPalindrome(n)):
                        palindrome.append(n)


res = print(max(palindrome))
        

        




